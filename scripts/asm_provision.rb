#!/bin/env ruby

require 'yaml'

# If a disk is smaller than this size it's considered a candidate for OCRVOTE
OCRVOTE_SIZE=5368709120
UDEV_RULE_FILE="/etc/udev/rules.d/80-oracle-asm.rules"
#UDEV_RULE_FILE="80-oracle-asm.rules"

# Tracks the number of disks in each group
ocrcount = 0
diskcount = 0

def generate_rule(device,name)

	# KERNEL=="sd*", SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", ENV{ID_SERIAL}=="36000c290e2feb0a79b4ebe855688ae7c", NAME+="oracleasm/ocrvote1", OWNER="oracle", GROUP="dba", MODE="0660"

	# scsi_id -g  -d /dev/sdb | awk ' { print $4; } '
	id = `scsi_id -g -d /dev/#{device} | awk ' { print $4; } '`.chomp
	rule = 	%Q!KERNEL=="sd*", SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", ENV{ID_SERIAL_SHORT}=="#{id}", SYMLINK+="oracleasm/#{name}", OWNER="oracle", GROUP="dba", MODE="0660"!
	return rule

end

# Main #
puts "Processing ASM disk devices"

# Get a hash of disk information from facter.
raw = `/opt/puppetlabs/bin/facter -y disks`
disks = YAML::load raw

# File to write to
udev_file = open(UDEV_RULE_FILE, "w")
udev_file.puts "# Generated by asm_provision.rb\n\n"

# Process each disk
disks['disks'].keys.sort.each do |disk|

	# Skip /dev/sda, it's the OS disk
	next if disk == "sda"

	# Get size in bytes
	size = disks['disks'][disk]['size_bytes']

	puts "Processing disk #{disk}, size #{size}"
	if size <= OCRVOTE_SIZE
		# Hey, it's an OCRVOTE disk
		ocrcount += 1;
		udev_name = "ocrvote#{ocrcount}"
	else
		diskcount += 1;
		udev_name = "disk#{diskcount}"
	end

	rule = generate_rule disk, udev_name
	udev_file.puts rule
	
end

udev_file.close

sleep 10
#system "udevadm trigger"
system "sudo start_udev"
